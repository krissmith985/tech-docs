
# Конфигурирование, запуск и взаимодействие с контрактами: конструкторы

Один и тот же смарт-контракт зачастую можно использовать для решения различных бизнес-кейсов. В простом случае от кейса
к кейсу отличаются параметры функции-конструктора смарт-контракта, в более сложном случае - какие-то фрагменты кода
включаются, какие-то исключаются из итогового исходного кода смарт-контракта. Например, в ERC20-токене в простом случае 
объем выпуска (totalSupply) задается как параметр функции-конструктора (здесь и далее под конструктором смарт-контракта 
понимается механизм, предложенный и используемый на платформе Smartz, чтобы не путать его с конструктором в терминах 
объектно-ориентированного программирования, последний будет называться функцией-конструктором). В более сложном случае, например, в токене может быть 
предусмотрено сжигание (burn), реализовать это можно, включив соответствующую функцию в код контракта, либо используя 
наследование: подключив в качестве контракта-родителя контракт токена, имеющего фукнцию сжигания *TODO*. При этом, вероятно, 
придется внести дополнительную логику, адаптирующую контракт-родитель к контракту-потомку (см. напр. SmartzToken *TODO*).

После того, как смарт-контракт запущен в блокчейн, требуется предоставить пользователям смарт-контракта Dapp,
с помощью которого будет удобно взаимодействовать со смарт-контрактом. Здесь также имеют место соображения, изложенные 
параграфом выше: с помощью подготовительных шагов различной сложности можно переиспользовать один и тот же Dapp в 
нескольких схожих бизнес-кейсах. Кроме того, простой Dapp может быть автоматически сгенерирован на основе 
смарт-контракта.

Мы считаем экономически нецелесообразным для решения каждого нового кейса привлекать разработчика. С другой стороны, 
есть полушуточное выражение "настоящий программист должен быть ленивым", за которым скрывается та мысль, что код 
хорошего программиста структурирован и удобен в переиспользовании, т.о. программисту понадобится меньше времени на 
выполение новой схожей задачи. Исходя из этих предпосылок мы сформулировали такое понятие, как конструктор 
смарт-контрактов. Механизм конструкторов смарт-контрактов на платформе Smartz реализует идеи, изложенные выше.

## Механика работы конструкторов смарт-контрактов

Имеем три ключевые стороны, участвующие в конфигурировании, запуске и взаимодействии со смарт-контрактом: разработчик 
смарт-контракта, пользователь, и платформа Smartz. Разработчик оформляет смарт-контракт в виде конструктора и делает
его переиспользуемым настолько, насколько считает целесообразным. Пользователь запускает смарт-контракт в блокчейн и 
взаимодействует со смарт-контрактом в блокчейне, при этом храня у себя и никому не передавая закрытые ключи своих
блокчейн-аккаунтов. Платформа Smartz выполняет конструктор и все вспомогательные операции, облегчая разработку и 
использование смарт-контрактов.

### Конфигурирование и запуск смарт-контракта

#### Взаимодействие Smartz и конструктора смарт-контрактов

Конструктор смарт-контрактов (далее конструктор) представляет из себя исходный код на том или ином языке 
программирования (Python, javascript, Java, Perl, Ruby, PHP, ...), имеющий определенный программный интерфейс. 
Взаимодействие со Smartz представляет из себя вызов тех или иных методов платформой.

Код конструктора и, как следствие,
код контрактов, им генерируемых, открыт - с тем чтобы имелась возможность производить его аудит. Перед выполнением 
происходит необходимая компиляция и кэширование полученного результата (напр., в случае Java получаем .class-файл, в 
случае Python - .pyc-файл).

Низкоуровневое взаимодействие с конструктором происходит в отдельном сервисе конструкторов. Его логика описана далее.
При необходимости вызвать метод конструктора платформа запускает скомпилированный код
конструктора в изолированном docker-контейнере. В контейнере ограничивается память, число процессов, время работы процессов, 
взаимодействие с дисковой подсистемой и сетью. В контейнер монтируются файл конструктора и библиотека, предоставляющая 
доступ к внутреннему API Smartz. Создание такого контейнера является относительно ресурсоемкой операцией (порядка 1-2
секунды), поэтому контейнеры переиспользуются. Статическая часть сервиса конструкторов, выполняемая в контейнере, 
загружает конкретный конструктор с помощью механики соотв. языка (напр., в случае Java - это ClassLoader, в случае 
Python - importlib) и вызывает нужный метод, передав параметры как аргументы вызова. Результат выполнения возвращается
в сервис конструкторов.

#### Вводные данные для конструктора

Конструктор описывает, какие вводные данные от пользователя он ожидает получить.
Это могут числа, строки, блокчейн-адреса, даты, и много более сложные данные, напр. коллекции и структуры. Кроме того,
на данные полезно наложить ограничения (напр. максимальное число подписей в контракте мультиподписи), так чтобы 
пользователь уже в интерфейсе имел возможность скорректировать данные, а разработчику не пришлось вновь и вновь 
реализовывать логику валидации данных. Это описание мы называем схемой данных.

Для задачи описания схемы данных мы используем готовые решения, близкие к статусу стандарта в той или иной области. Это
имеет следующие премущества:
* Часть разработчиков уже знакома с ними. Те же, кто не знаком, смогут переиспользовать полученные знания при работе над 
другими проектами
* Существуют готовые инструменты и библиотеки, напр. для валидации и генерации интерфейсов.

Smartz поддерживает описание входных данных в форматах [json schema](http://json-schema.org) и 
[OpenAPI Specification](https://swagger.io/specification/) (используется в [swagger](https://swagger.io/)). Кроме того,
Smartz предоставляет готовые описания некоторых типов данных, например Ethereum-адреса или unix timestamp, в терминах
соотв. схем.

Также, схема данных конструктора опционально может быть дополнена схемой отображения (`ui_schema`). Данная схема влияет на отрисовку
интерфейса ввода данных.

Когда пользователь хочет сконфигурировать и запустить некоторый смарт-контракт, он заходит на соотв. страницу на Smartz.
Со страницы отправляется RPC-запрос к платформе, а платформа получает схему данных и схему отображения конкретного конструктора с помощью
вызова `get_params` API конструктора. Схемы передаются через платформу обратно в браузер клиента, где 
обрабатывается клиентским кодом Smartz. На основании схемы данных и отображения автоматически генерируется пользовательский интерфейс
конфигурирования конструктора. В интерфейсе отрисовываются наиболее удобные для каждого конкретного типа данных виджеты
(напр. для unix timestamp - календарь с возможностью ввести дату и время, для блокчейн-адресов - адресная книга).
Когда пользователь отправляет форму с параметрами в конструктор, прежде всего происходит их быстрая валидация на соответствие
схеме данных на клиентской стороне, и при необходимости подсвечиваются ошибочно введенные поля. Если все в порядке, 
данные отправляются в Smartz.




## SDK


## API


## Интеграция с Github


## Интеграция с Travis CI


## Системы контрактов




# Управление контрактами

## Макретплейс виджетов

## Управление системой контрактов




# Платформа

## Аутентификация


## Маркетплейс

### Топы

### Рейтинговая система


## Уведомления


## Поиск


## Рекомендательная система


## Высокая доступность и отказоустойчивость




# Поддержка блокчейнов

## Ethereum


## EOS


## Bitcoin

### MAST


## NEM


## Waves


## Consortium блокчейны


## TON




# Интеграции смарт-контрактов


## Платежи


## API событий

### Telegram уведомления и боты


## Планировщик вызовов


## API виджетов


## Децентрализованный аудит


## Децентрализованные оракулы


## Переиспользование кода в блокчейнах


## Интеграция доверенных третьих лиц и нотариусов


## Работа с внешними наборами данных

### Маркетплейс внешних наборов данных


## Децентрализованная система репутаций




# Смарт-контракты




# Мобильные приложения




# Децентрализация Smartz

