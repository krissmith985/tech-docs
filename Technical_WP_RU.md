
# Конфигурирование, запуск и взаимодействие с контрактами: конструкторы

Один и тот же смарт-контракт зачастую можно использовать для решения различных бизнес-кейсов. В простом случае от кейса
к кейсу отличаются параметры функции-конструктора смарт-контракта, в более сложном случае - какие-то фрагменты кода
включаются, какие-то исключаются из итогового исходного кода смарт-контракта. Например, в ERC20-токене в простом случае 
объем выпуска (totalSupply) задается как параметр функции-конструктора (здесь и далее под конструктором смарт-контракта 
понимается механизм, предложенный и используемый на платформе Smartz, чтобы не путать его с конструктором в терминах 
объектно-ориентированного программирования, последний будет называться функцией-конструктором). В более сложном случае, например, в токене может быть 
предусмотрено сжигание (burn), реализовать это можно, включив соответствующую функцию в код контракта, либо используя 
наследование: подключив в качестве контракта-родителя контракт токена, имеющего функцию сжигания (см. напр. `BurnableToken`
в [erc20_token_constructor.py](https://github.com/smartzplatform/SDK/blob/ba8230d39e94f70a30e716f4f1e48ddd4e702432/constructor_examples/erc20_token_constructor.py)).
При этом, вероятно, придется внести дополнительную логику, адаптирующую контракт-родитель к контракту-потомку 
(см. напр. `transfer`, `transferFrom`, `burn` в [SmartzToken](https://github.com/smartzplatform/sale/blob/6a00b30ccaa3dabc515ad7dfd29bbd85848c9603/contracts/SmartzToken.sol)).

После того, как смарт-контракт запущен в блокчейн, требуется предоставить пользователям смарт-контракта DApp,
с помощью которого будет удобно взаимодействовать со смарт-контрактом. Здесь также имеют место соображения, изложенные 
параграфом выше: с помощью подготовительных шагов различной сложности можно переиспользовать один и тот же DApp в 
нескольких схожих бизнес-кейсах. Кроме того, простой DApp может быть автоматически сгенерирован на основе 
смарт-контракта.

Мы считаем экономически нецелесообразным для решения каждого нового кейса привлекать разработчика. С другой стороны, 
есть полушуточное выражение "настоящий программист должен быть ленивым", за которым скрывается та мысль, что код 
хорошего программиста структурирован и удобен в переиспользовании, т.о. программисту понадобится меньше времени на 
выполение новой схожей задачи. Исходя из этих предпосылок мы сформулировали такое понятие, как конструктор 
смарт-контрактов. Механизм конструкторов смарт-контрактов на платформе Smartz реализует идеи, изложенные выше.

## Механика работы конструкторов смарт-контрактов

Имеем три ключевые стороны, участвующие в конфигурировании, запуске и взаимодействии со смарт-контрактом: разработчик 
смарт-контракта, пользователь, и платформа Smartz. Разработчик оформляет смарт-контракт в виде конструктора и делает
его переиспользуемым настолько, насколько считает целесообразным. Пользователь запускает смарт-контракт в блокчейн и 
взаимодействует со смарт-контрактом в блокчейне, при этом храня у себя и никому не передавая закрытые ключи своих
блокчейн-аккаунтов. Платформа Smartz выполняет конструктор и все вспомогательные операции, облегчая разработку и 
использование смарт-контрактов.

### Конфигурирование и запуск смарт-контракта

#### Взаимодействие Smartz и конструктора смарт-контрактов

Конструктор смарт-контрактов (далее конструктор) представляет из себя исходный код на том или ином языке 
программирования (Python, javascript, Java, Perl, Ruby, PHP, ...), имеющий определенный программный интерфейс. 
Взаимодействие со Smartz представляет из себя вызов тех или иных методов платформой.

Код конструктора и, как следствие,
код контрактов, им генерируемых, открыт - с тем чтобы имелась возможность производить его аудит. Перед выполнением 
происходит необходимая компиляция и кэширование полученного результата (напр., в случае Java получаем .class-файл, в 
случае Python - .pyc-файл).

Низкоуровневое взаимодействие с конструктором происходит в отдельном сервисе конструкторов. Его логика описана далее.
При необходимости вызвать метод конструктора платформа запускает скомпилированный код
конструктора в изолированном docker-контейнере. В контейнере ограничивается память, число процессов, время работы процессов, 
взаимодействие с дисковой подсистемой и сетью. В контейнер монтируются файл конструктора и библиотека, предоставляющая 
доступ к внутреннему API Smartz. Создание такого контейнера является относительно ресурсоемкой операцией (порядка 1-2
секунды), поэтому контейнеры переиспользуются. Статическая часть сервиса конструкторов, выполняемая в контейнере, 
загружает конкретный конструктор с помощью механики соотв. языка (напр., в случае Java - это ClassLoader, в случае 
Python - importlib) и вызывает нужный метод, передав параметры как аргументы вызова. Результат выполнения возвращается
в сервис конструкторов.

#### Вводные данные для конструктора

Конструктор описывает, какие вводные данные от пользователя он ожидает получить.
Это могут числа, строки, блокчейн-адреса, даты, и много более сложные данные, напр. коллекции и структуры. Кроме того,
на данные полезно наложить ограничения (напр. максимальное число подписей в контракте мультиподписи), так чтобы 
пользователь уже в интерфейсе имел возможность скорректировать данные, а разработчику не пришлось вновь и вновь 
реализовывать логику валидации данных. Это описание мы называем схемой данных.

Для задачи описания схемы данных мы используем готовые решения, близкие к статусу стандарта в той или иной области. Это
имеет следующие премущества:
* Часть разработчиков уже знакома с ними. Те же, кто не знаком, смогут переиспользовать полученные знания при работе над 
другими проектами
* Существуют готовые инструменты и библиотеки, напр. для валидации и генерации интерфейсов.

Smartz планирует поддерживать описание входных данных в форматах [json schema](http://json-schema.org) и 
[OpenAPI Specification](https://swagger.io/specification/) (используется в [swagger](https://swagger.io/)). Кроме того,
Smartz предоставляет готовые описания некоторых типов данных, например Ethereum-адреса или unix timestamp, в терминах
соотв. схем.

Также, схема данных конструктора опционально может быть дополнена схемой отображения (`ui_schema`). Данная схема влияет на отрисовку
интерфейса ввода данных.

Когда пользователь хочет сконфигурировать и запустить некоторый смарт-контракт, он заходит на соотв. страницу на Smartz.
Со страницы отправляется RPC-запрос к платформе, а платформа получает схему данных и схему отображения конкретного конструктора с помощью
вызова `get_params` API конструктора. Схемы передаются через платформу обратно в браузер клиента, где 
обрабатывается клиентским кодом Smartz. На основании схемы данных и отображения автоматически генерируется пользовательский интерфейс
конфигурирования конструктора (задействуя компонент [react jsonschema form](https://github.com/mozilla-services/react-jsonschema-form)).
В интерфейсе отрисовываются наиболее удобные для каждого конкретного типа данных виджеты
(напр. для unix timestamp - календарь с возможностью ввести дату и время, для блокчейн-адресов - адресная книга).
Когда пользователь отправляет форму с параметрами в конструктор, прежде всего происходит их быстрая валидация на соответствие
схеме данных на клиентской стороне, и при необходимости подсвечиваются ошибочно введенные поля. Если все в порядке, 
данные отправляются в Smartz.

#### Генерация и компиляция смарт-контракта

На backend-стороне Smartz получает вводные данные для конструктора и прежде всего валидирует их на соответствие схеме
данных. В случае обнаружения ошибок информация об ошибках отправляется обратно на клиент с детализацией по каждому полю
(используя [python-модуль для работы с json schema](https://github.com/Julian/jsonschema)).
Если ошибок нет, вводные данные передаются в вызов `construct`.

Предполагается, что
конструктор прежде всего выполняет дополнительную, более сложную валидацию. Так, например, в случае multisig-кошелька
существует очевидное условие того, что число владельцев должно быть не меньше, чем кворум подписей. Подобное условие 
не видится целесообразным реализовывать на уровне схем данных. Результатом подобной валидации может явиться либо общая
ошибка, не специфичная для какого-либо конкретного поля (как в ранее приведенном примере), либо ошибка, связанная с 
конкретным полем. И тот и другой случай оформляются в соотв. API-ответ и возвращаются в Smartz, затем они будут переданы
и отрисованы на клиенте.

Затем выполняется генерация кода смарт-контрактов. Организация генерации находится в области ведения разработчика
конструктора, он довольно свободен в своем подходе. Smartz будет предоставлять библиотеку, облегчающую генерацию и делающую
ее более надежной. Так, например, она будет содержать методы безопасной подстановки значений в шаблон смарт-контракта (если 
подстановка не будет осуществлена, это будет автоматически расценено как ошибка - скорее всего, где-то опечатка), а также
проверки того, что все подстановки сделаны. Кроме того, Smartz будет предоставлять набор широко известных шаблонизаторов 
(напр. [Mustache](https://mustache.github.io), [Jinja](http://jinja.pocoo.org), [Thymeleaf](https://www.thymeleaf.org), и т.д.).

В дополнение к генерации, проведенной конструктором, Smartz дополняет исходный код инструкциями по переводу комиссий за
запуск контракта разработчику и платформе.

Результатом генерации является исходный код смарт-контракта на том или ином языке, напр. solidity. Исходный код далее 
передается в инфраструктуру компиляции - это отдельный сервис, использующий набор контейнеров, чтобы компилировать
код смарт-контракта нужной версией нужного языка (напр., в случае Ethereum используем C++ версию компилятора - `solc`).
При прочих равных условиях используется наибольшая допустимая стабильная версия языка.
Одновременно с этим, достигается повышенный уровень изоляции от остальных частей платформы.

В случае ошибок компиляции стандартный поток вывода компилятора возвращается из сервиса компиляции и сохраняется в 
хранилище Smartz. При этом применяем дедупликацию и сжатие записей, отнооящихся к одному и тому же конструктору - 
велика вероятность, что среди них существенен объем дублирования информации. Разработчик будет уведомлен о проблемах 
компиляции через механизм нотификаций, т.к. ошибка компиляции не является штатной ситуацией. Любые ошибки 
пользовательского ввода должны быть проконтролированы и предотвращены на этапе конструктора, далее все данные и код 
должны быть согласованы.

В случае успешной компиляции имеем в качестве результата бинарный код (напр. EVM-байткод, web assembly, и т.д.) и 
интерфейс (напр. ABI). Через Smartz они передаются в браузер пользователю.

Вместе с этим, вызывается метод `post_construct` конструктора, куда передаются вводные данные (те же, что были переданы 
в `construct`) и полученный интерфейс смарт-контракта. На основе этих параметров конструктор имеет возможность обогатить
стандартный DApp, генерируемый платформой, дополнительными данными (см. далее). Уже на этом этапе формируется т.н.
экземпляр (instance) конструктора в рамках платформы, в информацию о нем заносятся исходный код контракта, бинарный код,
интерфейс, дополнительная информация для DApp.

#### Загрузка смарт-контракта в блокчейн

После этапа компиляции в интерфейсе Smartz пользователю предлагается загрузить полученный смарт-контракт в блокчейн. 
Загрузка выполняется полностью на стороне пользователя посредством взаимодействия с блокчейном через браузер. В случае
сети Ethereum для этого подойдет любой браузер, управляющий аккаунтами пользователя и предоставляющий интерфейс 
[web3](https://github.com/ethereum/wiki/wiki/JavaScript-API) (напр. Chrome-подобные браузеры с расширением 
[MetaMask](https://metamask.io) или [Mist](https://github.com/ethereum/mist)). В случае EOS для этого подойдет любой 
браузер, управляющий аккаунтами пользователя и предоставляющий интерфейс [eosjs](https://github.com/EOSIO/eosjs).

Smartz сформирует и попробует отправить в сеть транзакцию загрузки контракта, при этом браузер попросит пользователя
подписать транзакцию, сообщив информацию о комиссиях сети, разработчика и платформы Smartz. Когда транзакция подписана,
она отправляется в сеть и Smartz ожидает ее включения в блокчейн майнерами. Когда транзакция включена в блокчейн,
платформа фиксирует необходимую блокчейн-информацию в экземпляре конструктора, напр. блокчейн-адрес контракта и id сети,
куда контракт был загружен.

После успешной загрузки контракта Smartz планирует автоматически в фоне верифицировать код контракта на профильных block
explorer (напр. [etherscan](https://etherscan.io)), если пользователь не запретил это действие.

Пользователю сообщается блокчейн-адрес контракта и ссылка на DApp, экземпляр добавляется в список экземпляров пользователя.

### Взаимодействие со смарт-контрактами



## SDK


## API


## Интеграция с Github


## Интеграция с Travis CI


## Системы контрактов




# Управление контрактами

## Макретплейс виджетов

## Управление системой контрактов




# Платформа

## Аутентификация


## Маркетплейс

### Топы

### Рейтинговая система


## Уведомления


## Поиск


## Рекомендательная система


## Высокая доступность и отказоустойчивость




# Поддержка блокчейнов

## Ethereum


## EOS


## Bitcoin

### MAST


## NEM


## Waves


## Consortium блокчейны


## TON




# Интеграции смарт-контрактов


## Платежи


## API событий

### Telegram уведомления и боты


## Планировщик вызовов


## API виджетов


## Децентрализованный аудит


## Децентрализованные оракулы


## Переиспользование кода в блокчейнах


## Интеграция доверенных третьих лиц и нотариусов


## Работа с внешними наборами данных

### Маркетплейс внешних наборов данных


## Децентрализованная система репутаций




# Смарт-контракты




# Мобильные приложения




# Децентрализация Smartz

